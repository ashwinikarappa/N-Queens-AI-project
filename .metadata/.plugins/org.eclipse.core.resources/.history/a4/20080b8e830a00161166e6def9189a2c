package ai.star.csp;

import java.util.ArrayList;
import java.util.Arrays;


public class ForwardCheckingWithMRV {
	public ArrayList<int[]> solutions = new ArrayList<int[]>();
	public int nodesComputed = 0;
	public void forwardCheckMRV(int numberOfQueens, boolean compare){
		PuzzleBoard puzzleBoard = new PuzzleBoard(numberOfQueens);
		forwardCheckingWithMRV(numberOfQueens, 0, puzzleBoard, compare);
		
	}
	public int getFirstSafePlace(PuzzleBoard c, int qi){
		for(int i=0;i<c.numberOfQueens; i++){
			if(c.safePlaces[qi][i])
				return i;
		}
		return -1;
	}
	
	public void updateSafePlaces(PuzzleBoard c, int queen, int placedIndex){
		int row = queen + 1;
		int column = placedIndex + 1;
		
		// updating all row 
		while( row < c.numberOfQueens){
			c.safePlaces[row][placedIndex] = false;
			row+=1;
		}
		// updating right diagonal elements
		row = queen + 1;
		while((row < c.numberOfQueens) && (column < c.numberOfQueens)){
			c.safePlaces[row][column] = false;
			row += 1;
			column += 1;
		}
		// updating left diagonal elements
		row = queen + 1;
		column = placedIndex - 1;
		while((row < c.numberOfQueens) && (column >= 0 )){
			c.safePlaces[row][column] = false;
			row += 1;
			column -= 1;
		}
	}
	public int forwardCheckingWithMRV(int n, int qi,PuzzleBoard c, boolean compare){
		int returnValue = 0;
		nodesComputed++;
		MinConflicts m = new MinConflicts();
		PuzzleBoard newChessBoard;
		int[] conflicts = m.computeConflicts(c);
			if(m.conflictsExist(conflicts,c.queenPlacement)){
				do{
					newChessBoard = new PuzzleBoard(c);
					int safePlace = getFirstSafePlace(c,qi);
					if(safePlace == -1){
						return -1;
					}else{
						
						newChessBoard.queenPlacement[qi] = safePlace;
						updateSafePlaces(newChessBoard,qi,safePlace);
						System.out.println("initial queenPlacement "+Arrays.toString(newChessBoard.queenPlacement));
						int queenIndex = chooseQueenWithMRV(newChessBoard);
						if(!(queenIndex == -1))
							returnValue = forwardCheckingWithMRV(n, queenIndex,newChessBoard, compare);
						
					}
				c.safePlaces[qi][safePlace] = false;
				
				}while(returnValue == -1);
			}
			else{
				
				solutions.add(c.queenPlacement);
				System.out.println(nodesComputed);
				if(!compare){
					qi--;
					return -1;
				}
				return 0;
			}

			
			return 0;
	}
	
	int chooseQueenWithMRV(PuzzleBoard chessBoard){
		MinConflicts m = new MinConflicts();
		int minMRV = Integer.MAX_VALUE;
		int minMRVQueenIndex = -1;
		for(int i=0;i<chessBoard.numberOfQueens;i++){
			int conflicts[] = m.computeNewPositionConflicts(i, chessBoard);
			int MRV = computeMRV(conflicts);
			if(MRV < minMRV){
				minMRV = MRV;
				minMRVQueenIndex = i;
			}
			
		}
		if(minMRV == 0)
			return -1;
		return minMRVQueenIndex;
	}
	int computeMRV(int[] conflicts){
		int MRV = 0;
		for(int i=0;i<conflicts.length;i++)
			if(conflicts[i]==0)
				MRV++;
		return MRV;
	}
	public static void main(String[] args) {
		ForwardCheckingWithMRV fMRV = new ForwardCheckingWithMRV();
		fMRV.forwardCheckMRV(4, true);
	}
}
