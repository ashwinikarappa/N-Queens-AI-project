package ai.star.csp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Backtracking {
	public static int nodesComputed = 0;
	public static int numberOfSolutions = 0;
	public static ArrayList<int []> solutions = new ArrayList<int[]>();

	private static boolean checkIfSafePlaceForQueen(int columnIndex, int queenIndex,
			int[] board) {
		for (int i = 0; i < queenIndex; i++) {
			// Cannot place two queens in same column
			if (board[i] == columnIndex) {
				return false;
			}
			// Cannot place queens on diagonals of any other queens already placed
			if (Math.abs(board[i] - columnIndex) == Math.abs(i - queenIndex)) {
				return false;
			}
		}
		return true;
	}

	public static void main(String args[]) {
		System.out.println("How many queens? ");
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		Backtracking b = new Backtracking();
		b.backtrack(n, true);
		b.backtrack(n, false);

	}

	public void backtrack(int n, boolean compare) {
		int[] board = new int[n];
		placeQueen(0, board);
	}

	public void placeQueen(int queenIndex, int[] chessBoard) {
		int numberOfQueens = chessBoard.length;

		if (queenIndex == numberOfQueens) {
			System.out.println(Arrays.toString(chessBoard) + " Nodes computed "
					+ nodesComputed);
			numberOfSolutions++;
		} else {
			for (int column = 0; column < numberOfQueens; column++) {
				nodesComputed++;
				if (checkIfSafePlaceForQueen(column, queenIndex, chessBoard)) {
					chessBoard[queenIndex] = column;
					placeQueen(queenIndex + 1, chessBoard);
					if (numberOfSolutions == 1)
						return;
					else
						chessBoard[queenIndex] = -1;

				}
			}

		}

	}

}
