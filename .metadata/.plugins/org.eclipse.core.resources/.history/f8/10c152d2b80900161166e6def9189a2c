package ai.star.csp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

public class MinConflicts {
	private int nodesComputed = 0;
	private ArrayList<int[]> solutions = new ArrayList<int[]>();
	private ArrayList<Integer> randomNumbers = new ArrayList<Integer>(); 
	private int[] conflicts;
	
	public void minConflicts(int numberOfQueens){
		NqueenPuzzleSolver puzzleBoard = new NqueenPuzzleSolver(numberOfQueens);
		conflicts = new int[numberOfQueens];
		for(int i=0;i< numberOfQueens;i++)
			puzzleBoard.queenPlacement[i] = i;
		shuffleArray(puzzleBoard.queenPlacement);
		System.out.println(Arrays.toString(puzzleBoard.queenPlacement));
		computeConflicts(puzzleBoard);
		System.out.println(Arrays.toString(conflicts));

		
	}
	private void computeConflicts(NqueenPuzzleSolver puzzleBoard){
		for(int i=0;i< puzzleBoard.numberOfQueens;i++){
			conflicts[i] = computeNumberOfAttackingQueens(puzzleBoard.queenPlacement[i],i,puzzleBoard.queenPlacement);
		}
	}
	private int computeNumberOfAttackingQueens(int columnIndex, int queenIndex,
			int[] board) {
		int conflicts = 0;
		for (int i = 0; i < board.length; i++) {
			// Cannot place two queens in same column
			if(i != queenIndex){
			if (board[i] == columnIndex) {
				conflicts++;
			}
			// Cannot place queens on diagonals of any other queens already placed
			else if (Math.abs(board[i] - columnIndex) == Math.abs(i - queenIndex)) {
				conflicts++;
			}
			}
		}
		return conflicts;
	}
	void shuffleArray(int[] queenPlacement)
	  {
	    // If running on Java 6 or older, use `new Random()` on RHS here
	    Random rnd = new Random();
	    for (int i = queenPlacement.length - 1; i > 0; i--)
	    {
	      int index = rnd.nextInt(i + 1);
	      // Simple swap
	      int a = queenPlacement[index];
	      queenPlacement[index] = queenPlacement[i];
	      queenPlacement[i] = a;
	    }
	  }
	public static void main(String[] args) {
		MinConflicts m = new MinConflicts();
		m.minConflicts(4);
	}
}
